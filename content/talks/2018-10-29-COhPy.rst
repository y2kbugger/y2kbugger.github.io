Learn how computers work from opcodes to IO — Building a Virtual Machine in Python
##################################################################################

:date: 2018-10-29
:tags: COhPy, Python, Retrocomputing
:author: zak kohler
:summary: COhPy October Meeting, Columbus, Ohio
:status: published

@ **COhPy October Meeting**, *Columbus, Ohio*

`Slides <https://drive.google.com/open?id=1Laue0CnRrtKDYxWJLnYe6d2f8ZJHxvSshZZY9GZTpEI>`_ 

.. code-block:: giturl

   git clone --branch 2018-10-29-COhPy https://y2kbugger@bitbucket.org/y2kbugger/sapy.git

Programming languages are designed for a specific level of abstraction or distance from the hardware. The main trade off is "developer productivity" vs "control over hardware". C and assembly are low level and therefore map closely to CPU instructions. Python on the other hand goes through many layers, libraries, and a virtual machine before the CPU is reached. This allows powerful programs to be written concisely and cross-platform—but it also leaves an immense "Magic Valley" of faith. Eliminating the magic can lead to interesting insights and a greater appreciation for the subtleties of performance, quirks of legacy compatibility, and the purpose of operating systems.

We will build up a virtual machine in Python, and I will connect these concepts to concrete hardware details as they naturally emerge. Guaranteed material: opcodes, CPU, data/address bus, ROM/RAM, and IO. Bonus material: assemblers, interrupts, tty output.

