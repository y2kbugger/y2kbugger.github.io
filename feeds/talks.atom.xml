<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>y2kbugger - talks</title><link href="http://blog.y2kbugger.com/" rel="alternate"></link><link href="http://blog.y2kbugger.com/feeds/talks.atom.xml" rel="self"></link><id>http://blog.y2kbugger.com/</id><updated>2020-08-24T22:29:22-04:00</updated><entry><title>Learn How Computers Work Between Silicon and Assembly: Build a CPU with Python</title><link href="http://blog.y2kbugger.com/2019-07-28-pyohio.html" rel="alternate"></link><published>2019-07-28T00:00:00-04:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2019-07-28:/2019-07-28-pyohio.html</id><summary type="html">&lt;p class="first last"&gt;PyOhio 2019, Columbus, Ohio&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&amp;#64; &lt;strong&gt;PyOhio&lt;/strong&gt;, &lt;em&gt;Columbus, Ohio&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://drive.google.com/open?id=1u8qlAK4SeqFX3ybT7zVuKWItMvCadhsgF9WmCCOM3dQ"&gt;Slides&lt;/a&gt; &lt;a class="reference external" href="https://gke.mybinder.org/v2/git/https%3A%2F%2Fy2kbugger%40bitbucket.org%2Fy2kbugger%2Fsapy.git/de5086ea943c94fec40e14478257ab2716e28c96?filepath=Simple%20As%20Possible.ipynb"&gt;Live Jupyter Notebook&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://y2kbugger@github.com/y2kbugger/sapy.git
&lt;/pre&gt;&lt;/div&gt;
&lt;!-- git clone - -branch 2019-07-28-PyOhio https://y2kbugger@github.com/y2kbugger/sapy.git --&gt;
&lt;div class="videoembed-container"&gt;
&lt;iframe class="videoembed-iframe" src="https://www.youtube.com/embed/iJqCMoAMlMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;Programming languages are designed for a specific level of abstraction or distance from the hardware. The main trade off is &amp;quot;developer productivity&amp;quot; vs. &amp;quot;control over hardware&amp;quot;. C and assembly are low level and therefore map closely to CPU instructions. Python on the other hand goes through many layers, libraries, and a virtual machine before the CPU is reached. This allows powerful programs to be written concisely and cross-platform—but it also conceals the true nature at the heart of our modern world. Unveiling the magic within can lead to interesting insights about how computing got to where it is today.&lt;/p&gt;
&lt;p&gt;We will build up CPU focused on transparency, interactivity, and modularity. Our CPU has a configurable architecture and machine language. Yes, you can invent your own assembly instructors to add functionality. We will cover registers, data/address busses, memory (ROM/RAM), IO, and assemblers.&lt;/p&gt;
</content><category term="talks"></category><category term="PyOhio"></category><category term="Python"></category><category term="Retrocomputing"></category><category term="CPUs"></category></entry><entry><title>Learn how computers work between silicon and assembly — Build a CPU with Python</title><link href="http://blog.y2kbugger.com/2018-12-11-carpe.html" rel="alternate"></link><published>2018-12-11T00:00:00-05:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2018-12-11:/2018-12-11-carpe.html</id><summary type="html">&lt;p class="first last"&gt;CARPE December Meeting, Columbus, Ohio&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&amp;#64; &lt;strong&gt;CARPE December Meeting&lt;/strong&gt;, &lt;em&gt;Columbus, Ohio&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://drive.google.com/open?id=12KYvWFvr7uSeOLgl2vSXf_TAWIMcBV3WC4VD1vP2Oag"&gt;Slides&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone --branch 2018-12-11-CARPE https://y2kbugger@github.com/y2kbugger/sapy.git
&lt;/pre&gt;&lt;/div&gt;
&lt;img alt="Slide about my CPU presentation." class="align-center" src="https://lh3.googleusercontent.com/ZXuaqX-m6ynsOKnvGmfCwM3ov2loiSR3v2blG5vykRSaExcyKPn1WL-BS2tEj5kS_Dp0PojmRHXiyDcioR6WHKNAOWr_P_hSRZ0Vj98yR8fn-mBovfziqiXAZj5poI7Wl_O98YkYQIQ=w596-h447-no" style="width: 100%;" /&gt;
&lt;p&gt;Programming languages are designed for a specific level of abstraction or distance from the hardware. The main trade off is &amp;quot;developer productivity&amp;quot; vs &amp;quot;control over hardware&amp;quot;. C and assembly are low level and therefore map closely to CPU instructions. Python on the other hand goes through many layers, libraries, and a virtual machine before the CPU is reached. This allows powerful programs to be written concisely and cross-platform—but it also conceals the true nature at the heart of our modern world. Unveiling the magic within can lead to interesting insights about how computing got to where it is today.&lt;/p&gt;
&lt;p&gt;We will build up CPU focused on transparency, interactivity, and modularity. Our CPU has a configurable architecture and machine language. Yes, you can invent your own assembly instructors to add functionality. We will cover registers, data/address busses, memory&amp;nbsp;(ROM/RAM), IO, and assemblers.&lt;/p&gt;
&lt;p&gt;Specs for nerds: 8-bit words, 256 memory addresses, Von Neumann w/ shared address+data bus, DMA with numpy based buffer.&lt;/p&gt;
</content><category term="talks"></category><category term="CARPE"></category><category term="Python"></category><category term="Retrocomputing"></category></entry><entry><title>Learn how computers work from opcodes to IO — Building a Virtual Machine in Python</title><link href="http://blog.y2kbugger.com/2018-10-29-cohpy.html" rel="alternate"></link><published>2018-10-29T00:00:00-04:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2018-10-29:/2018-10-29-cohpy.html</id><summary type="html">&lt;p class="first last"&gt;COhPy October Meeting, Columbus, Ohio&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&amp;#64; &lt;strong&gt;COhPy October Meeting&lt;/strong&gt;, &lt;em&gt;Columbus, Ohio&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://drive.google.com/open?id=1Laue0CnRrtKDYxWJLnYe6d2f8ZJHxvSshZZY9GZTpEI"&gt;Slides&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone --branch 2018-10-29-COhPy https://y2kbugger@github.com/y2kbugger/sapy.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Programming languages are designed for a specific level of abstraction or distance from the hardware. The main trade off is &amp;quot;developer productivity&amp;quot; vs &amp;quot;control over hardware&amp;quot;. C and assembly are low level and therefore map closely to CPU instructions. Python on the other hand goes through many layers, libraries, and a virtual machine before the CPU is reached. This allows powerful programs to be written concisely and cross-platform—but it also leaves an immense &amp;quot;Magic Valley&amp;quot; of faith. Eliminating the magic can lead to interesting insights and a greater appreciation for the subtleties of performance, quirks of legacy compatibility, and the purpose of operating systems.&lt;/p&gt;
&lt;p&gt;We will build up a virtual machine in Python, and I will connect these concepts to concrete hardware details as they naturally emerge. Guaranteed material: opcodes, CPU, data/address bus, ROM/RAM, and IO. Bonus material: assemblers, interrupts, tty output.&lt;/p&gt;
</content><category term="talks"></category><category term="COhPy"></category><category term="Python"></category><category term="Retrocomputing"></category></entry><entry><title>The Art of (Virtual) Rubber Compounding</title><link href="http://blog.y2kbugger.com/2018-09-12-tire-society.html" rel="alternate"></link><published>2018-09-12T00:00:00-04:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2018-09-12:/2018-09-12-tire-society.html</id><summary type="html">&lt;p class="first last"&gt;Tire Society, Akron, OH&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&amp;#64; &lt;strong&gt;Tire Society&lt;/strong&gt;, &lt;em&gt;Akron, OH&lt;/em&gt;&lt;/p&gt;
&lt;img alt="First time in front of such a large audience." src="https://lh3.googleusercontent.com/zfciYIV-Jb8SrG3rkqVaagMX7JbQW25udAJwTbq3zSqNf-y-5xMJdw8QlH76WVIBB_nY0tEKAy68nRczf4AYMrK86ay_Kfa4BDfFuXPTOR7khUnxq60hnLDFiwYZuJxOMRpAb6_IFOU=w530-h678-no" style="width: 40%;" /&gt;
&lt;p&gt;The art of rubber compounding has historically been mastered by a small group of experts with extreme breadth and depth of experience. The rising trend of fluidity between companies is making loyal lifetime &amp;quot;sage compounders&amp;quot; a dying breed and organizations must find new ways to capture and archive experience despite having turnover. Minimizing the time before a new hire becomes productive also becomes critical.&lt;/p&gt;
&lt;p&gt;Complex interactions between raw materials and processing make &amp;quot;rules of thumb&amp;quot; insufficient for discovering new technology. These guidelines, even when properly captured, are often overfit to specific scenarios and can be skewed by human cognitive biases—a disadvantage that is especially detrimental when exploring new technology. Machine Learning, on the other hand, is a method of encoding &amp;quot;experience&amp;quot; based on many observations. Industries that have been revolutionized by data science include algorithmic trading, healthcare, and retail. Just as data has taken the art out of sales and stocks, so too could it allow for more accurate formulation development and reduced cycle time.&lt;/p&gt;
&lt;p&gt;Two main challenges affect the amount and quality of data that can be acquired:&lt;/p&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;Many of the standard tests for raw materials are related to verifying material identity and purity rather than predicting compound performance.&lt;/li&gt;
&lt;li&gt;Even in the largest rubber development laboratories, the number of material-to-compound observations is relatively small compared to the vast amounts of data available in other industries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These challenges will need to be overcome in order to develop models of structure / property relationships to evaluate, iterate, and tune each component of a rubber formula and quickly react to business needs.&lt;/p&gt;
</content><category term="talks"></category><category term="Tire-Society"></category></entry><entry><title>Using Termux: Creating a first class Python environment on Android CLI or how I pushed mobile development too far.</title><link href="http://blog.y2kbugger.com/2018-06-15-cohpy.html" rel="alternate"></link><published>2018-06-15T00:00:00-04:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2018-06-15:/2018-06-15-cohpy.html</id><summary type="html">&lt;p class="first last"&gt;COhPy June Meeting, Columbus, Ohio&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&amp;#64; &lt;strong&gt;COhPy June Meeting&lt;/strong&gt;, &lt;em&gt;Columbus, Ohio&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://drive.google.com/open?id=1I6jmlPeBjosl1zJ_XNTXPfcvKGAKvzoYqedefctW6m0"&gt;Slides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So you've tried QPython but it just doesn't feel complete? Not sure how to &amp;quot;go mobile&amp;quot; as laptops become uselessly obsolete? Whether you love VIM or not you'll enjoy having the full power of a linux CLI to manage your Android Python development environment. Combining the Termux package repo and pip allows installing most packages directly and building many more from source using clang. Pipenv and git can also be used to synchronize development between your phone and other environments, and if you're a vimmer autocomplete is just a few extensions away. Data scientists will also enjoy the unexpected interactive support.&lt;/p&gt;
</content><category term="talks"></category><category term="COhPy"></category><category term="Python"></category><category term="Android"></category><category term="Termux"></category></entry></feed>