<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>y2kbugger - programming</title><link href="http://blog.y2kbugger.com/" rel="alternate"></link><link href="http://blog.y2kbugger.com/feeds/programming.atom.xml" rel="self"></link><id>http://blog.y2kbugger.com/</id><updated>2020-09-01T02:32:27-04:00</updated><entry><title>I am now a maintainer on the Arch User Repository</title><link href="http://blog.y2kbugger.com/first_arch_user_repository_submission.html" rel="alternate"></link><published>2020-04-14T00:06:28-04:00</published><updated>2020-08-24T22:29:22-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2020-04-14:/first_arch_user_repository_submission.html</id><summary type="html">&lt;p class="first last"&gt;Just made my first submission to the arch user repository (AUR)&lt;/p&gt;
</summary><content type="html">&lt;!-- Google Photos Album: https://photos.app.goo.gl/dfXck6rcLDcZHtv17 --&gt;
&lt;div class="section" id="long-time-user-first-time-maintainer"&gt;
&lt;h2&gt;Long time user, first time maintainer&lt;/h2&gt;
&lt;p&gt;I've been a Linux user for a decade now, Ubuntu at first, but I switched to &lt;a class="reference external" href="https://archlinux.org"&gt;ArchLinux&lt;/a&gt; after a year or two. I quickly found the &lt;a class="reference external" href="https://aur.archlinux.org/"&gt;Arch User Repository&lt;/a&gt; or AUR to be a treasure trove of free (libre) software; I am still in awe today. On ms windows, finding software meant downloading binaries from sketchy freeware sites. The prospects were better on Ubuntu since many software projects engaged with the community and produces regular releases. One drawback however were the stale repos, some packages on ubuntu were still pointing at releases that were years old.The Ubuntu &lt;a class="reference external" href="https://launchpad.net/ubuntu/+ppas"&gt;Personal Package Archives&lt;/a&gt; PPAs was supposed to solve this, but I never had  good luck with them. The packages always seemed random whether or not they were compatible and maintained.&lt;/p&gt;
&lt;img alt="ArchLinux Logo" src="https://lh3.googleusercontent.com/mapAQeHjDZmDn4Jq-FXyEhuFDEB6IHuEBzk8egTflCpiwLU9g0-W_YevSXbZEE-tQopVtEIJLO_rkjgf2TjA_olTqV7gGPiiDPKliO23xXNlOENJnDhobYLeLh7w942lCrhiASjMVHA=w683-h228-no" /&gt;
&lt;p&gt;Enter ArchLinux, everything is on the bleeding edge. The vast majority of typical software needs is packaged and up-to-date. For more custom software, there is the AUR. It started as just people sharing recipes for building packages...and well, that's still the case and it's a &lt;em&gt;really&lt;/em&gt; good thing too, it's beauty is in the simplicity. Packaging makes sure that the software you install goes in cleanly and can be removed without leftover files. You can think of ArchLinux as basically a package manger &lt;a class="footnote-reference" href="#pacman" id="id1"&gt;[1]&lt;/a&gt; and a wonderful community. The AUR acts as a funnel for new packages to become official in the community repository, which are built packages rather than just recipes.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="pacman" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;See pacman: &lt;a class="reference external" href="https://wiki.archlinux.org/index.php/pacman"&gt;https://wiki.archlinux.org/index.php/pacman&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="my-contribution"&gt;
&lt;h2&gt;My contribution&lt;/h2&gt;
&lt;p&gt;For my first contribution I wanted something simple, just to learn the process. At work I have been spending a lot of time with the conda package manager, and a few months ago I submitted my first conda-forge recipe. For a long time I have wanted to put something on AUR and now that packing is fresh on my mind I figure it's a good time to get this one under my belt. I chose a shell script that I have used for years; it is a fork of a now deleted AUR package. Since it's a shell script it still needs to be installed to the system but it doesn't have the complication of needing to be compiled.&lt;/p&gt;
&lt;img alt="My AUR package page" src="https://lh3.googleusercontent.com/Cc_WYvWQQrft1j2Qgb6mjuLL5t1zpBXlPVjViDqeBuPgJLK0Spus6pszYoEhzmO5gTY-NH2uJ44rq1CyeDapBKiJhOkhAKwJc77_sZpWv9JL9qgza5Yawd9ilg58bau2i1nR8vu6xEk=w503-h216-no" /&gt;
&lt;p&gt;The package is called &lt;cite&gt;dmenu-recent-aliases&lt;/cite&gt;, and it is a lightweight application launcher. It provides fuzzy searching for all the executables on your &lt;cite&gt;PATH&lt;/cite&gt; and also includes your custom bash functions and aliases. I have added a few extra features as well, for the full docs see &lt;a class="reference external" href="https://gitlab.com/y2kbugger-projects/scripts/dmenu-recent-aliases"&gt;https://gitlab.com/y2kbugger-projects/scripts/dmenu-recent-aliases&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A second reason for choosing this one is that there is some demand for the script and the original is no longer being maintained.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="Broken link on aur" src="https://lh3.googleusercontent.com/oh9j6EPpcdpLD-1pWDsRzv18wSoKxlbB_bMcunePT2W8DGunnHpAswL7riiCzTgzkyiQ_I0h_00VP-mDrfH3ZeHMmnCwn9PtHVUu219CopWoYB7GI-NQell_BQ3yM096_IMTp5bAXlk=w438-h78-no" /&gt;
&lt;p class="caption"&gt;The archwiki still has a link to the old package, but it no longer exists.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="become-a-maintainer-yourself"&gt;
&lt;h2&gt;Become a maintainer yourself&lt;/h2&gt;
&lt;p&gt;Before you start to make a package, you should be familiar how to manually install other's packages from the AUR. Avoid AUR helpers for a while, trust me.&lt;/p&gt;
&lt;p&gt;Here is the quickstart guide:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_packages"&gt;https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_packages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As far as the packaging process goes, it's not too difficult but I can't begin to cover it all here. Instead, I recommend reading at least all of these:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Creating_packages"&gt;https://wiki.archlinux.org/index.php/Creating_packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Arch_package_guidelines"&gt;https://wiki.archlinux.org/index.php/Arch_package_guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/AUR_submission_guidelines"&gt;https://wiki.archlinux.org/index.php/AUR_submission_guidelines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It may also be helpful to check out my minimal &lt;cite&gt;PKGBUILD&lt;/cite&gt; here.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://aur.archlinux.org/dmenu-recent-aliases-git.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After you cobble together what you think is a good &lt;cite&gt;PKGBUILD&lt;/cite&gt; you can ask for a review on the &lt;cite&gt;#archlinux-aur&lt;/cite&gt; IRC. Try &lt;a class="reference external" href="https://www.irccloud.com/"&gt;IRCCloud&lt;/a&gt; if you aren't familiar with IRC.&lt;/p&gt;
&lt;p&gt;Finally, submitting is as easy as a git push, but be sure all of your i's are dotted and t's are crossed.&lt;/p&gt;
&lt;p&gt;Now you are &amp;lt;strike&amp;gt;all done&amp;lt;/strike&amp;gt; just beginning. As a maintainer it's your job to keep the package up-to-date and incorporate suggestions from the community.&lt;/p&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="Linux"></category><category term="packaging"></category><category term="OpenSource"></category><category term="ArchLinux"></category></entry><entry><title>The C Programming Language</title><link href="http://blog.y2kbugger.com/the-c-programming-language.html" rel="alternate"></link><published>2019-12-31T00:00:00-05:00</published><updated>2020-07-19T22:54:03-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2019-12-31:/the-c-programming-language.html</id><summary type="html">&lt;p class="first last"&gt;Learning C from the book co-written by the one of the original language designers.&lt;/p&gt;
</summary><content type="html">&lt;!-- Google Photos Album: https://photos.app.goo.gl/dfXck6rcLDcZHtv17 --&gt;
&lt;div class="section" id="get-close-to-the-hardware-so-you-can-c"&gt;
&lt;h2&gt;Get close to the hardware so you can C&lt;/h2&gt;
&lt;p&gt;Since I have been learning about hardware and operating systems I wanted to learn a language which is conducive for having full control of computer hardware. C is not just good for this, the level of control C gives you was tuned for writing portable operating systems. The tooling, community, and educational resources reflect this legacy.&lt;/p&gt;
&lt;p&gt;I chose to read the Kernighan and Ritchie book because I had heard that it was not just a good book for C, but good for programming in general. There is also a historical value to learning from a primary source. I can confirm this. Working through the exercises are key to understanding why C exists.&lt;/p&gt;
&lt;p&gt;Here are my attempts at the exercises:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone git@github.com:y2kbugger/kr.git
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="the-k-r-approach"&gt;
&lt;h3&gt;The K&amp;amp;R approach&lt;/h3&gt;
&lt;p&gt;Early on they teach about structuring modules so that code and interfaces could be reused. When I previously learning C++ the reason for header files seemed to be hand waved. I appreciated the way these concepts were treated in K&amp;amp;R.&lt;/p&gt;
&lt;p&gt;Later in the book though we work through reimplement functions from the standard lib. This was insightful, especially the ones which dealt with memory management such as malloc, calloc, and free as well as the Unix system interface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;I would definitely recommend the book to anyone interested in learning about computers. If all you care about is writing programs/computation, other languages could twist you brain in other directions (Haskell, etc), but learning C through K&amp;amp;R is a good start to learning about how computers actually work.&lt;/p&gt;
&lt;div class="section" id="but-shouldn-t-i-learn-something-modern-like-c"&gt;
&lt;h4&gt;But shouldn't I learn something modern like C++?&lt;/h4&gt;
&lt;p&gt;As a side note, don't be swayed to learn C++ merely because C is a subset. The argument goes like this: if you learn C++ you'll also learn C for free. This isn't true. If you want something a bit higher level for systems programming, I've heard good things about Rust.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="C"></category><category term="books"></category></entry><entry><title>MMIX WASM</title><link href="http://blog.y2kbugger.com/mmix-wasm.html" rel="alternate"></link><published>2019-09-28T02:14:30-04:00</published><updated>2020-09-01T02:32:27-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2019-09-28:/mmix-wasm.html</id><summary type="html">&lt;p class="first last"&gt;Compiling the MMIX Assembler and Simulator to Web Assembly&lt;/p&gt;
</summary><content type="html">&lt;!-- Google Photos Album: https://photos.app.goo.gl/dfXck6rcLDcZHtv17 --&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#fast-feedback-for-the-art-of-computer-programming-exercises" id="id1"&gt;Fast feedback for The Art of Computer Programming Exercises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dependencies" id="id2"&gt;Dependencies&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mmixlib" id="id3"&gt;MMIXlib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#emscripten" id="id4"&gt;Emscripten&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#approach" id="id5"&gt;Approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#demo" id="id6"&gt;Demo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="fast-feedback-for-the-art-of-computer-programming-exercises"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Fast feedback for The Art of Computer Programming Exercises&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I started working through the &lt;a class="reference external" href="https://blog.y2kbugger.com/reading-taocp-mmix.html"&gt;exercises in TAOCP&lt;/a&gt;, I wanted a quicker way to work on the problems in the MMIX assembly language. I was also in the process of learning C so I was interested in trying to understand the code behind MMIXware, the simulators for the MMIX computer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dependencies"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Dependencies&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="mmixlib"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;MMIXlib&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;MMIXware is made up of multiple programs, including an assembler and a simulator. Details can be found at the homepage here: &lt;a class="reference external" href="http://mmix.cs.hm.edu"&gt;http://mmix.cs.hm.edu&lt;/a&gt;. When browsing the SVN trunk I noticed a project called MMIXlib. This is a refactoring effort by Martin Ruckert to partition the original MMIX tools into something he could integrate into an IDE. I decided to use this as the base for how I would plug into the MMIX assembler and simulator.&lt;/p&gt;
&lt;p&gt;One thing that is surprising if you haven't seen it before is MMIXware being written in CWEB, This is a literate programming system developed by Donald Knuth. The CWEB files compile to C, but I needed to install all of texlive to do so. There is a rule that you are not to change the original source code but only apply CWEB style &amp;quot;change files&amp;quot;. This allows the entire refactoring to actually be a layer of explained changes applied to the original MMIXware.&lt;/p&gt;
&lt;p&gt;When I was working through the compilation process, I found a couple of errors in MMIXlib, and also I suggested a small enhancement to the Makefile. As is tradition with Donald Knuth's projects, there was a reward for finding errors in MMIXware. Even though I think my contribution was small I'm proud to have gotten a MMIX shirt for the contribution.&lt;/p&gt;
&lt;img alt="mmix shirt" src="https://lh3.googleusercontent.com/pw/ACtC-3cFCw5pcP4PjQ42htLHTNWtHNCmNJq4lxvQjEMtxlMtKjBK_P6DHh2c05aIIGVsdb5RBNnMFY7dOzUsMa8EECwxEvNJY8tTF4hpSk00R7sk52YwUXK55kyJkIC9epT5yxHK_k8DqhKY6qrrMXL1YOaC3Q=w742-h989-no" /&gt;
&lt;/div&gt;
&lt;div class="section" id="emscripten"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id4"&gt;Emscripten&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I decided to compile to MMIXware to web assembly for two reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;I wanted to see what it took to compile some legacy C program to WASM&lt;/li&gt;
&lt;li&gt;The web is flexible for UIs, I could make it as polished as I wanted&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="approach"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MMIXlib allows you to hook into various parts of the simulator and emscripten allows exposing C functions directly to JavaScript. This allows the main loop to run in js, with all of the hard work being done on the WASM side. Emscripten also has the ability to fake out a file system and expose that to JavaScript as well. This allowed me to be extra lazy and not even have to modify the IO of MMIXware.&lt;/p&gt;
&lt;p&gt;The hardest part was deciphering compile errors/warnings that manifested from compiling old C code with a modern compiler while also tracing through CWEB source and change files.&lt;/p&gt;
&lt;p&gt;The part that I can take the most credit for is adding the register watcher. This involved work on both the js side and the C code. I hope to add the ability for watching multiple registers. Other inner workings I would like to expose are special registers and memory ranges.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="demo"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Demo&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As you modify the input, the simulator will reassemble and restart. Choose a general register to watch, 0-255. You can also change the frequency we run the simulator at.&lt;/p&gt;
&lt;p&gt;More programming examples can be found in the MMIX repository &lt;a class="reference external" href="https://gitlab.lrz.de/mmix/mmixware"&gt;https://gitlab.lrz.de/mmix/mmixware&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone git@github.com:y2kbugger/mmix-wasm.git
&lt;/pre&gt;&lt;/div&gt;
&lt;iframe frameborder="0" width="100%" height="1400px"  src="https://d1aby3vgncc46a.cloudfront.net/mmix-wasm.html"&gt;&lt;/iframe&gt;&lt;/div&gt;
</content><category term="programming"></category><category term="assembly"></category><category term="algorithms"></category><category term="MMIX"></category><category term="TAOCP"></category><category term="books"></category></entry><entry><title>MMIX - Working on TAOCP in RISC</title><link href="http://blog.y2kbugger.com/reading-taocp-mmix.html" rel="alternate"></link><published>2018-12-27T00:00:00-05:00</published><updated>2020-05-29T15:18:21-04:00</updated><author><name>zak kohler</name></author><id>tag:blog.y2kbugger.com,2018-12-27:/reading-taocp-mmix.html</id><summary type="html">&lt;p class="first last"&gt;How to read The Art of Computer Programming and do the exercises in modern RISC rather than a 1960s style architecture.&lt;/p&gt;
</summary><content type="html">&lt;!-- Google Photos Album: https://photos.app.goo.gl/dfXck6rcLDcZHtv17 --&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This article I will cover why I want to read TAOCP as well as my approach. Because the books are in various states of publication, one must use additional resources besides the book to enjoy the updated RISC material.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-art-of-computer-programming"&gt;
&lt;h2&gt;The Art Of Computer Programming&lt;/h2&gt;
&lt;p&gt;The Art of Computer Programming is a legendary multi-volume computer science textbook. It was originally conceived in 1962 as a 12 chapter book documenting a wide range of algorithms. The rapid pace of change in computer science made these chapters a moving target; while Volume 1 was released in 1968, Volume 4 is still in progress as of 2020 &lt;a class="footnote-reference" href="#taocpwiki" id="id1"&gt;[1]&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="The Art of Computer Programming" class="align-center" src="https://lh3.googleusercontent.com/pw/ACtC-3fz2RxP2aYWm20KIl9hU_BkQcyTNxSmewF-0TM7KLe2BbVwUsml4DmX7kgHf4E8vARaOSQFJ-d1zou3FMoD4hjaX8q3jSFcKZwty559C8BiomechHmEW7gwmIBd8kJvi0u4Zqx0I6UDlA65QuBUX_CEdQ=w500-h431-no" style="width: 33%;" /&gt;
&lt;p&gt;The book is notable for being comprehensive and precise as well as for the extreme care given to the exercises and solutions. Because it's known for being a huge undertaking, some people quip that the book is often recommended without actually having been read. I suspect this is because the algorithms are explained using assembly language rather than structured programming which some people deem as impenetrably  obscure.&lt;/p&gt;
&lt;div class="section" id="why-i-want-to-read-it"&gt;
&lt;h3&gt;Why I want to read it&lt;/h3&gt;
&lt;p&gt;I believe it when Knuth says that you learn something extra about algorithms at the interface of hardware and software. In C for example you may not know what is happening in hardware when you write an if statement, but in assembly this is in-your-face.&lt;/p&gt;
&lt;p&gt;He puts it like this:&lt;/p&gt;
&lt;blockquote&gt;
One of the principal goals of my books is to show how high-level constructions are actually implemented in machines, not simply to show how they are applied. &lt;a class="footnote-reference" href="#knuthmmix" id="id2"&gt;[3]&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;This aligns with my goal of exploring computers to the lowest levels including operating systems as well as CPUs. The more I can understand the software-hardware interface, the happier I will be. Learning algorithms via TAOCP is the software side of my strategy. On the hardware side I'm exploring TTL logic, CPU design, and simple cases of systems integration using vintage microprocessors such as z80, 6502 and 1802. This has also led me to explore prototyping via FPGAs and one day I hope to design a CPU core and bootstrap up to a self-hosting multitasking development environment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="mix"&gt;
&lt;h2&gt;MIX&lt;/h2&gt;
&lt;p&gt;In order to facilitate the teaching of algorithms and how they interact with hardware, Knuth developed a CPU architecture and corresponding assembly language.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MIX is a hypothetical computer used in Donald Knuth's monograph, The Art of
Computer Programming (TAOCP). MIX's model number is 1009, which was derived
by combining the model numbers and names of several contemporaneous,
commercial machines deemed significant by the author. Also, &amp;quot;MIX&amp;quot; read as a
Roman numeral is 1009.&lt;/p&gt;
&lt;p class="attribution"&gt;&amp;mdash;Wikipedia &lt;a class="footnote-reference" href="#mixwiki" id="id3"&gt;[2]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Knuth states that &amp;quot;MIX is very much like nearly every computer of the 1960s and 1970s except that it is, perhaps, nicer.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mmix"&gt;
&lt;h2&gt;MMIX&lt;/h2&gt;
&lt;img alt="MMIX" src="https://lh3.googleusercontent.com/pw/ACtC-3cmwaXo3THz54nq3bz9bWJ9N3hK5zfHL9o4JAsdri5mZ7AgP4LPpilaSkxatNxccRDbxKgZ65jDB08Akq1UMV1nGGqktUrq8uXJFhs9ODgtUQ1wT6SAapWlK5zTWLP-tliFKDBuARvEVYmHnRilf89CsQ=w572-h85-no" /&gt;
&lt;p&gt;Computer have changed significantly since the 60s, as Knuth explains:&lt;/p&gt;
&lt;blockquote&gt;
Thirty years have passed since the MIX computer was designed, and computer architecture has been converging during those years towards a rather different style of machine &lt;a class="footnote-reference" href="#knuthmmix" id="id4"&gt;[3]&lt;/a&gt;.&lt;/blockquote&gt;
&lt;img alt="Under Construction" src="https://lh3.googleusercontent.com/pw/ACtC-3fRUt39VqJiEOQ9LhFcwVrsuth55pRA44lyfN51vxoNG0v0DshXSPqc5SdCtLdAnCWPOfLaP-KS5iDdApF0YKfAM8SBZmgyI61tLobpe8lVmxjGyNFkdrOpxaOD4cpvrJddWkV7lvJAUvmMONAoJF6dtg=w683-h131-no" /&gt;
&lt;p&gt;In Volume 1 3rd Edition, he states his plans to replace MIX:&lt;/p&gt;
&lt;blockquote&gt;
However, it must be admitted that MIX is now quite obsolete. Therefore MIX will be replaced in subsequent editions of this book by a new machine called MMIX, the 2009. MMIX will be a so-called reduced instruction set computer (RISC). [...] It will be even nicer than MIX and will be similar to machines that have become dominant during the 1990s.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="subsequent-editions-fascicles"&gt;
&lt;h2&gt;Subsequent editions, fascicles&lt;/h2&gt;
&lt;p&gt;So we've chosen to explore MMIX, the forward looking ISA of TAOCP, now what? The dilemma we face is that the next edition has not been released yet. The most recent edition, V1 3e, has all of the questions and answers still written with MIX.&lt;/p&gt;
&lt;img alt="The three required books for MMIX" class="align-center" src="https://lh3.googleusercontent.com/pw/ACtC-3cuRVuJCUSUugDBBPjEjvV-g4h9rh4NuHipmWhjvJbgS3zKZGBYrkea6kFi6MYL6-gC-mmhqHvCIB6FMcG6fHf_wzLQ3FSggliRMHXReoaJXcB4XEkEYYUFVJ-tzUwnb0Htv9v26hcMSSMf6vrfC46HXQ=w683-h459-no" /&gt;
&lt;p&gt;So what choice do we have then? Well Donald has kindly release what is known as V1F1 or &lt;em&gt;The Art of Computer Programming, Volume 1, Fasicle 1 -- A RISC Computer for the New Millennium&lt;/em&gt;. A fascicle is a &amp;quot;a separately published installment of a book or other printed work.&amp;quot; Basically it acts as a patch for V1 3e. Replacing the chapter explaining MIX with the MMIX equivalent. It is available on &lt;a class="reference external" href="https://https://www.amazon.com/Art-Computer-Programming-Fascicle-Millennium/dp/0201853922/"&gt;Amazon&lt;/a&gt;. Fun note, these are printed on demand when you place your order.&lt;/p&gt;
&lt;div class="figure align-right"&gt;
&lt;img alt="On demand printing" src="https://lh3.googleusercontent.com/pw/ACtC-3dsG1EowkXAZFHTN5U6GoiV7aHLiLZj4qS4T-LL4_G7bSkTLQFbru0xIrfOSHiVYxg3UDcSqjI3_DC0HQvAiMNwwaaUBNkcFkEqL0Zx5m11fvY5ctohhCmg8e60Y_SAX8k1jyvou9g_R2JqBcRycjhmbg=w509-h678-no" style="width: 66%;" /&gt;
&lt;p class="caption"&gt;Printed the day after I ordered on Amazon.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;That covers the basics of the language, but all of the solutions also needed reworked. Knuth put out a request for people to collaborate on the solutions, a project he called MMIXMasters &lt;a class="footnote-reference" href="#mmixmasters" id="id5"&gt;[4]&lt;/a&gt;. The end result of this is known as the MMIX supplement. It's available on the web, &lt;a class="reference external" href="http://mmix.cs.hm.edu/supplement/index.html"&gt;http://mmix.cs.hm.edu/supplement/index.html&lt;/a&gt; as well as in printed form on Amazon: &lt;a class="reference external" href="https://www.amazon.com/MMIX-Supplement-Computer-Programming-Volumes/dp/0133992314"&gt;MMIX Supplement&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="future-work"&gt;
&lt;h2&gt;Future Work&lt;/h2&gt;
&lt;p&gt;I'm excited to keep working through these exercises. To assist the process of testing various algorithms, I've started a side-project which I have compiled Knuth's original MMIX toolchain to WASM and wrapped it in a simple IDE for MMIX in the browser.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-and-risc-v"&gt;
&lt;h2&gt;Hardware and RISC-V&lt;/h2&gt;
&lt;p&gt;I plan to continue working on the hardware side in tandem as well. I dream of the day I could write some of these algorithms for an FPGA RISC-V CPU or even more exciting, a toy ISA of my own.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="taocpwiki" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming"&gt;https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="mixwiki" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/MIX"&gt;https://en.wikipedia.org/wiki/MIX&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="knuthmmix" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[3]&lt;/td&gt;&lt;td&gt;&lt;em&gt;(&lt;a class="fn-backref" href="#id2"&gt;1&lt;/a&gt;, &lt;a class="fn-backref" href="#id4"&gt;2&lt;/a&gt;)&lt;/em&gt; &lt;a class="reference external" href="https://www-cs-faculty.stanford.edu/~knuth/mmix.html"&gt;https://www-cs-faculty.stanford.edu/~knuth/mmix.html&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="mmixmasters" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://mmix.cs.hm.edu/mmixmasters/index.html"&gt;http://mmix.cs.hm.edu/mmixmasters/index.html&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="assembly"></category><category term="algorithms"></category><category term="MMIX"></category><category term="TAOCP"></category><category term="books"></category></entry></feed>